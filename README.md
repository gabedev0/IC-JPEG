# DCT Image Compression & Analysis Tool

[![Python 3.12+](https://img.shields.io/badge/python-3.12+-blue.svg)](https://www.python.org/downloads/)

A Python tool to compress images using a DCT-based pipeline (similar to JPEG) and analyze the trade-offs between compression level, quality, and performance across three different DCT implementations.

This project implements and compares three DCT methods based on research papers, including color space transformation, quantization, and comprehensive quality metrics analysis. All implementations use **pure Python with integer arithmetic** for educational purposes and fair comparison.

## ‚ú® Key Features

-   **JPEG-like Pipeline**: Implements the core compression steps: RGB to YCbCr conversion, 8x8 block processing, DCT, Quantization (Q50 standard tables), and the inverse operations.
-   **Three DCT Implementations** (all in pure Python):
    -   **Loeffler Fast DCT**: Optimized algorithm with only 11 multiplications (Loeffler et al. 1989)
    -   **Matrix DCT**: Pure mathematical implementation using direct DCT-II formula
    -   **Approximate DCT**: Cintra-Bayer 2011 low-complexity approximation with integer-only matrix (values {-1, 0, 1})
-   **Dual Comparison Modes**: 
    -   **K-Factor Mode**: Compare methods across different compression factors [2.0, 5.0, 10.0, 15.0]
    -   **Bitrate Mode**: Compare methods at target bitrates [0.1, 0.25, 0.5, 1.0 bpp]
-   **üìä Comprehensive Analysis**: Automatically calculates and plots key metrics:
    -   PSNR (Peak Signal-to-Noise Ratio)
    -   SSIM (Structural Similarity Index)
    -   Processing Time (ms)
    -   Bitrate estimation (bpp - bits per pixel)
    -   Rate-Distortion Efficiency (PSNR/bpp)
-   **Method Comparison**: Built-in comparison tool (`compare_methods.py`) that evaluates all three DCT methods on the same dataset.
-   **Rich Visualizations**: Generates multiple plots for each image, including quality vs. compression factor, performance trade-offs, and dataset-wide summary boxplots.
-   **Organized Output**: Saves compressed images, plots, and numerical results into structured output directories.

## üîß How It Works

The compression process follows these main steps for each image:
1.  **Color Space Conversion**: The input RGB image is converted to the YCbCr color space. This separates luminance (Y) from chrominance (Cb, Cr), which is more efficient for compression.
2.  **Block Splitting**: Each channel (Y, Cb, Cr) is divided into 8x8 pixel blocks.
3.  **Discrete Cosine Transform (DCT)**: A 2D DCT is applied to each block, converting spatial pixel values into frequency coefficients.
4.  **Quantization**: Frequency coefficients are quantized using standard JPEG tables, scaled by a configurable factor `k`. This is the main lossy step where information is discarded.
5.  **Reconstruction**: The inverse process (de-quantization, inverse DCT, merging blocks, and YCbCr to RGB conversion) is applied to reconstruct the image.

## üìÇ File Structure

```
.
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ imgs/              # Place your images here
‚îÇ   ‚îú‚îÄ‚îÄ constantes.py      # Constants, quantization tables (Q50_LUMA, Q50_CHROMA)
‚îÇ   ‚îú‚îÄ‚îÄ dct.py             # Three DCT implementations (Loeffler, Matrix, Approximate)
‚îÇ   ‚îú‚îÄ‚îÄ main.py            # Main script - processes images with selected DCT method
‚îÇ   ‚îú‚îÄ‚îÄ pipeline.py        # Core compression/decompression pipeline
‚îÇ   ‚îî‚îÄ‚îÄ plots.py           # Metrics calculation and visualization
‚îú‚îÄ‚îÄ compare_methods.py     # Compare all three DCT methods side-by-side
‚îú‚îÄ‚îÄ results_{method}/      # Compressed images output (created at runtime)
‚îú‚îÄ‚îÄ plots_{method}/        # Analysis plots and metrics (created at runtime)
‚îî‚îÄ‚îÄ requirements.txt       # Project dependencies
```

## üöÄ Getting Started

### Prerequisites

-   Python 3.10 or higher
-   `pip` and `venv`

## üìã Usage

### Single Method Analysis

1.  **Add Images**: Place the images you want to process inside the `src/imgs/` directory.

2.  **Configure**: Open `src/main.py` to adjust parameters:
    ```python
    DCT_METHOD = 'loeffler'  # Options: 'loeffler', 'matrix', 'approximate'
    K_FACTORS = [2.0, 5.0, 10.0, 15.0]  # Compression factors
    ```

3.  **Run the script:**
    ```sh
    python src/main.py
    ```

## üìà Output

After running, the script will generate directories based on the selected method:

-   `results_{method}/`: Compressed output images, organized by original image name
-   `plots_{method}/`: Analysis plots and text files with numerical results
    - Individual image plots (PSNR, SSIM, Bitrate vs k-factor)
    - Dataset summary boxplots
    - Detailed metrics in `results.txt` files

## üî¨ DCT Methods Comparison

### Performance Characteristics

| Method | Quality (PSNR) | Speed | Complexity | Accuracy |
|--------|---------------|-------|------------|----------|
| **Approximate** | ‚≠ê‚≠ê‚≠ê‚≠ê (24.38 dB) | ‚ö°‚ö°‚ö°‚ö° Fastest (~2.0s) | 0 multiplications | Approximate |
| **Loeffler** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (26.06 dB) | ‚ö°‚ö°‚ö° Fast (~2.8s) | 11 multiplications | Exact |
| **Matrix** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (25.90 dB) | ‚ö° Slowest (~15.4s) | 64 multiplications | Exact |

*Benchmark results using pure Python implementation with k=10.0*

### Implementation Details

- **Approximate (Cintra-Bayer 2011)**: 
  - Uses integer-only T matrix with values {-1, 0, 1}
  - Only normalization by 1/‚àö8 required (no S matrix)
  - Zero multiplications in matrix operations
  - **26% faster than Loeffler** in Python implementation
  - ~1.5-2 dB PSNR reduction compared to exact methods
  
- **Loeffler (1989)**: 
  - 11 multiplications per 1D-DCT
  - Butterfly structure with optimized data flow
  - Numerically exact DCT-II
  - Good balance between speed and quality
  
- **Matrix**: 
  - Direct DCT-II formula: `Y[k] = Œ£ x[n]¬∑cos(œÄ¬∑k¬∑(2n+1)/(2N))`
  - 64 multiplications per 8x8 block
  - Reference implementation for validation
  - Slowest but most straightforward

All methods use:
- **Integer arithmetic** (scale factor 1000) for consistency
- Standard JPEG **Q50 quantization tables** (Wallace 1992)
- Same pipeline: YCbCr conversion ‚Üí 8x8 blocks ‚Üí DCT ‚Üí Quantization ‚Üí IDCT ‚Üí RGB

## üìö References

This project is based on the following research papers:

1. **Loeffler, C., Ligtenberg, A., & Moschytz, G. S. (1989)**  
   "Practical fast 1-D DCT algorithms with 11 multiplications"  
   *Proceedings of the International Conference on Acoustics, Speech, and Signal Processing*  
   - Butterfly structure with optimal multiplication count

2. **Wallace, G. K. (1992)**  
   "The JPEG still picture compression standard"  
   *IEEE Transactions on Consumer Electronics, 38(1)*  
   - Standard Q50 quantization tables used in this implementation

3. **Cintra, R. J., & Bayer, F. M. (2011)**  
   "A DCT approximation for image compression"  
   *IEEE Signal Processing Letters, 18(10), 579-583*  
   - Integer-only T matrix approximation with {-1, 0, 1} values
   - Normalization by 1/‚àö8 only (no separate S matrix needed)

## üìÑ License

MIT License - see [LICENSE](LICENSE) file for details.

---

**Developed for comparative analysis of DCT algorithms in image compression.**

---
---

### üáßüá∑ Vers√£o em Portugu√™s

# Ferramenta de Compress√£o e An√°lise de Imagens com DCT

[![Python 3.12+](https://img.shields.io/badge/python-3.12+-blue.svg)](https://www.python.org/downloads/)

Uma ferramenta em Python para comprimir imagens usando um pipeline baseado em DCT e analisar os trade-offs entre n√≠vel de compress√£o, qualidade e performance.

Este projeto implementa e compara tr√™s m√©todos DCT baseados em artigos cient√≠ficos, incluindo transforma√ß√£o de espa√ßo de cores, quantiza√ß√£o e an√°lise completa de m√©tricas de qualidade. **Todas as implementa√ß√µes usam Python puro com aritm√©tica inteira** para fins educacionais e compara√ß√£o justa.

## ‚ú® Principais Funcionalidades

-   **Pipeline similar ao JPEG**: Implementa os passos principais de compress√£o: convers√£o de RGB para YCbCr, processamento em blocos 8x8, DCT, Quantiza√ß√£o (tabelas Q50 padr√£o) e as opera√ß√µes inversas.
-   **Tr√™s Implementa√ß√µes de DCT** (todas em Python puro):
    -   **DCT R√°pida de Loeffler**: Algoritmo otimizado com apenas 11 multiplica√ß√µes (Loeffler et al. 1989)
    -   **DCT Matricial**: Implementa√ß√£o matem√°tica pura usando f√≥rmula direta da DCT-II
    -   **DCT Aproximada**: Aproxima√ß√£o Cintra-Bayer 2011 de baixa complexidade com matriz inteira (valores {-1, 0, 1})
-   **Dois Modos de Compara√ß√£o**:
    -   **Modo K-Factor**: Compara m√©todos em diferentes fatores de compress√£o [2.0, 5.0, 10.0, 15.0]
    -   **Modo Bitrate**: Compara m√©todos em taxas de bits alvo [0.1, 0.25, 0.5, 1.0 bpp]
-   **üìä An√°lise Completa**: Calcula e plota automaticamente m√©tricas essenciais:
    -   PSNR (Peak Signal-to-Noise Ratio)
    -   SSIM (Structural Similarity Index)
    -   Tempo de Processamento (ms)
    -   Estimativa de taxa de bits (bpp - bits por pixel)
    -   Efici√™ncia Rate-Distortion (PSNR/bpp)
-   **Compara√ß√£o de M√©todos**: Ferramenta integrada (`compare_methods.py`) que avalia os tr√™s m√©todos DCT no mesmo dataset.
-   **Visualiza√ß√µes Ricas**: Gera m√∫ltiplos gr√°ficos para cada imagem, incluindo qualidade vs. fator de compress√£o, trade-offs de performance e boxplots que resumem os resultados de todo o dataset.
-   **Sa√≠da Organizada**: Salva as imagens comprimidas, os gr√°ficos e os resultados num√©ricos em diret√≥rios de sa√≠da estruturados.

## üîß Como Funciona

O processo de compress√£o segue os seguintes passos para cada imagem:
1.  **Convers√£o de Espa√ßo de Cores**: A imagem RGB de entrada √© convertida para o espa√ßo de cores YCbCr. Isso separa a lumin√¢ncia (Y) da cromin√¢ncia (Cb, Cr), o que √© mais eficiente para a compress√£o.
2.  **Divis√£o em Blocos**: Cada canal (Y, Cb, Cr) √© dividido em blocos de 8x8 pixels.
3.  **Transformada Discreta de Cosseno (DCT)**: Uma DCT 2D √© aplicada a cada bloco, convertendo valores espaciais de pixels em coeficientes de frequ√™ncia.
4.  **Quantiza√ß√£o**: Os coeficientes de frequ√™ncia s√£o quantizados usando tabelas padr√£o do JPEG, escalonadas por um fator `k` configur√°vel. Este √© o principal passo com perdas, onde informa√ß√£o √© descartada.
5.  **Reconstru√ß√£o**: O processo inverso (dequantiza√ß√£o, DCT inversa, uni√£o dos blocos e convers√£o de YCbCr para RGB) √© aplicado para reconstruir a imagem.

## üìÇ Estrutura de Arquivos

```
.
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ imgs/              # Coloque suas imagens aqui
‚îÇ   ‚îú‚îÄ‚îÄ constantes.py      # Constantes e tabelas de quantiza√ß√£o (Q50_LUMA, Q50_CHROMA)
‚îÇ   ‚îú‚îÄ‚îÄ dct.py             # Tr√™s implementa√ß√µes DCT (Loeffler, Matricial, Aproximada)
‚îÇ   ‚îú‚îÄ‚îÄ main.py            # Script principal - processa imagens com m√©todo DCT selecionado
‚îÇ   ‚îú‚îÄ‚îÄ pipeline.py        # Pipeline de compress√£o/descompress√£o
‚îÇ   ‚îî‚îÄ‚îÄ plots.py           # C√°lculo de m√©tricas e visualiza√ß√£o
‚îú‚îÄ‚îÄ compare_methods.py     # Compara os tr√™s m√©todos DCT lado a lado
‚îú‚îÄ‚îÄ results_{metodo}/      # Imagens comprimidas (criado em tempo de execu√ß√£o)
‚îú‚îÄ‚îÄ plots_{metodo}/        # Gr√°ficos de an√°lise e m√©tricas (criado em tempo de execu√ß√£o)
‚îî‚îÄ‚îÄ requirements.txt       # Depend√™ncias do projeto
```

## üöÄ Como Come√ßar

### Pr√©-requisitos

-   Python 3.10 ou superior
-   `pip` e `venv`

## üìã Como Usar

### An√°lise de M√©todo √önico

1.  **Adicione Imagens**: Coloque as imagens que voc√™ deseja processar dentro do diret√≥rio `src/imgs/`.

2.  **Configure**: Abra `src/main.py` para ajustar os par√¢metros:
    ```python
    DCT_METHOD = 'loeffler'  # Op√ß√µes: 'loeffler', 'matrix', 'approximate'
    K_FACTORS = [2.0, 5.0, 10.0, 15.0]  # Fatores de compress√£o
    ```

3.  **Execute o script:**
    ```sh
    python src/main.py
    ```


## üìà Sa√≠da

Ap√≥s a execu√ß√£o, o script ir√° gerar diret√≥rios baseados no m√©todo selecionado:

-   `results_{metodo}/`: Imagens comprimidas, organizadas por nome da imagem original
-   `plots_{metodo}/`: Gr√°ficos de an√°lise e arquivos de texto com resultados num√©ricos
    - Gr√°ficos individuais por imagem (PSNR, SSIM, Bitrate vs fator k)
    - Boxplots resumindo todo o dataset
    - M√©tricas detalhadas em arquivos `results.txt`

## üî¨ Compara√ß√£o dos M√©todos DCT

### Caracter√≠sticas de Performance

| M√©todo | Qualidade (PSNR) | Velocidade | Complexidade | Precis√£o |
|--------|-----------------|-----------|--------------|----------|
| **Aproximada** | ‚≠ê‚≠ê‚≠ê‚≠ê (24.38 dB) | ‚ö°‚ö°‚ö°‚ö° Mais R√°pida (~2.0s) | 0 multiplica√ß√µes | Aproximada |
| **Loeffler** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (26.06 dB) | ‚ö°‚ö°‚ö° R√°pida (~2.8s) | 11 multiplica√ß√µes | Exata |
| **Matricial** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (25.90 dB) | ‚ö° Mais Lenta (~15.4s) | 64 multiplica√ß√µes | Exata |

*Resultados de benchmark usando implementa√ß√£o Python pura com k=10.0*

### Detalhes de Implementa√ß√£o

- **Aproximada (Cintra-Bayer 2011)**: 
  - Usa matriz T inteira com valores {-1, 0, 1}
  - Apenas normaliza√ß√£o por 1/‚àö8 necess√°ria (sem matriz S)
  - Zero multiplica√ß√µes nas opera√ß√µes matriciais
  - **26% mais r√°pida que Loeffler** na implementa√ß√£o Python
  - Redu√ß√£o de ~1.5-2 dB PSNR comparada aos m√©todos exatos
  
- **Loeffler (1989)**: 
  - 11 multiplica√ß√µes por 1D-DCT
  - Estrutura butterfly com fluxo de dados otimizado
  - DCT-II numericamente exata
  - Bom equil√≠brio entre velocidade e qualidade
  
- **Matricial**: 
  - F√≥rmula direta da DCT-II: `Y[k] = Œ£ x[n]¬∑cos(œÄ¬∑k¬∑(2n+1)/(2N))`
  - 64 multiplica√ß√µes por bloco 8x8
  - Implementa√ß√£o de refer√™ncia para valida√ß√£o
  - Mais lenta mas mais direta

Todos os m√©todos usam:
- **Aritm√©tica inteira** (fator de escala 1000) para consist√™ncia
- **Tabelas de quantiza√ß√£o Q50** padr√£o JPEG (Wallace 1992)
- Mesmo pipeline: convers√£o YCbCr ‚Üí blocos 8x8 ‚Üí DCT ‚Üí Quantiza√ß√£o ‚Üí IDCT ‚Üí RGB

- **Loeffler**: 11 multiplica√ß√µes, opera√ß√µes butterfly, otimizado para velocidade
- **Matricial**: Implementa√ß√£o direta da f√≥rmula DCT-II com N¬≤=64 multiplica√ß√µes
- **Aproximada**: Algoritmo BAS-2008, opera√ß√µes apenas com inteiros, sem fun√ß√µes trigonom√©tricas

Todos os m√©todos usam:
- Tabelas de quantiza√ß√£o Q50 padr√£o do JPEG (do paper de Wallace)
- Aritm√©tica inteira (fator de escala 1000) para precis√£o
- Mesmo pipeline de quantiza√ß√£o para compara√ß√£o justa

## üìö Refer√™ncias Bibliogr√°ficas

Este projeto √© baseado nos seguintes papers de pesquisa (dispon√≠veis em `PDFs/`):

1. **Loeffler, C., Ligtenberg, A., & Moschytz, G. S. (1989)**  
   "Practical fast 1-D DCT algorithms with 11 multiplications"  
   *Proceedings of the International Conference on Acoustics, Speech, and Signal Processing*

2. **Wallace, G. K. (1992)**  
   "The JPEG still picture compression standard"  
   *IEEE Transactions on Consumer Electronics, 38(1)*

3. **Cintra, R. J., & Bayer, F. M. (2011)**  
   "A DCT approximation for image compression"  
   *IEEE Signal Processing Letters, 18(10)*

## üìÑ Licen√ßa

MIT License - veja o arquivo [LICENSE](LICENSE) para detalhes.

---

**Desenvolvido para an√°lise comparativa de algoritmos DCT em compress√£o de imagens.**